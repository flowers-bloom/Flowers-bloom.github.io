<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MyISAM和InnoDB底层索引结构]]></title>
    <url>%2F2019%2F09%2F17%2FMyISAM%E5%92%8CInnoDB%E5%BA%95%E5%B1%82%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[索引和数据的存储下面有两张表信息，role表使用MyISAM引擎存储，而user表用InnoDB引擎存储：下面是两种表在磁盘中的索引文件和数据文件： role表 role.frm：表结构文件 role.MYD：数据文件（MyISAM Data） role.MYI：索引文件（MyISAM Index） user表 user.frm：表结构文件 user.ibd：索引和数据文件（InnoDB Index and Data） 由上可知，MyISAM引擎将索引和数据分开文件存储，而InnoDB将索引和数据集中存储。因此，也称MyISAM的索引为非聚集索引，InnoDB的索引为聚集索引。 主键索引和辅助索引结构对数据库底层实现了解的读者应该都清楚，数据库索引是采用B+ Tree存储，在非叶结点存储索引和指针，在叶节点存储数据和指针。其中，非叶节点存储子树根节点的地址，而叶节点的指针存储数据文件的地址。 MyISAM 主键索引以col1列作为主键索引，对应结构请看下面示例图：查询流程：持有某条记录的主键id，在B+ Tree中遍历节点，找到含有目标主键id的节点并取得数据文件的存储地址，再到指定存储地址取得数据。 辅助索引以col2列作为辅助索引，得到与主键索引相同的结构，请看下面示例图： InnoDB 主键索引由于InnoDB为聚集索引，所以叶节点存储了索引以及对应的数据。 辅助索引以姓名作为辅助索引，节点中存储的不再是id，而是姓名。并且，叶节点中第一行存储辅助索引，第二行存储主键索引。通过第二行主键索引便于查询记录其他数据。 参考：https://blog.csdn.net/u010922732/article/details/82994253#%E4%B8%80%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BD%9C%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%AF%B9%E8%B1%A1]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数据库索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql语句执行过程]]></title>
    <url>%2F2019%2F09%2F16%2Fsql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[客户端将语句发送到服务端在SQL语句执行过程中，客户端和服务端都会有一个数据库进程，两者一一对应并发生数据传递。其中，服务端的数据库进程真正处理SQL语句的执行。 语句解析当语句传输到服务端之后，服务端进程会对语句进行解析，解析分为若干步。 查询高速缓存在服务端进程解析语句之前，会先将SQL字符语句转化为一个ASCII等效数字码，传递给hash函数获得一个hash值。然后在shared pool中的高速缓存中查找相同的hash值。如果存在相同的hash值，则直接使用在shared pool的高速缓存中已解析的版本，这称为软解析。否则，进行下面的正常解析，这对应称为硬解析。所以，如果使用软解析，在内存中读取数据，将可以大大地提升SQL语句的查询效率。这也是为什么redis数据库比mysql类型数据库查询速度高的关键原因。 语句解析 语句语法检查检查语句是否符合SQL语法，而不检查表名、字段名等值 语句语义检查检查语句表名、字段名、索引等值 获得对象解析锁检查语句的语法和语义都正确后，系统会对查询对象加锁，避免在查询过程中对象被改变，以保证数据的一致性 数据访问权限核对查询对象加锁后，系统还要核实当前连接用户是否有该数据访问的权限 确定最佳执行计划权限也合格之后，服务端根据一定的规则对SQL语句进行优化，确定可能的最低成本的执行计划。但是，这个优化是有限的。所以，在开发过程中，开发人员对SQL语句进行优化，产生的作用远大于数据库的自我优化。绑定变量如果SQL语句中使用了变量绑定，那么需要进行变量绑定，将变量值带入执行计划。如果在高速缓存中存在已解析的版本，则跳过该步。语句执行 SELECT语句 首先服务端进程判断所需数据是否存在db buffer中，如果存在且可用，那么直接使用db buffer中的数据 如果db buffer中不存在可用数据，则从数据库文件中查询数据，并将这些数据存入到数据缓存区（buffer cache） DML语句（insert、delete、update） 检查所需数据是否存在缓存区，如果存在，则直接跳到步骤3 若所需数据不在缓存区，则从数据库文件中读取数据到缓存区 对想要修改的表取得的数据行锁定，并且之后加上独占锁 将数据的redo记录复制到redo log buffer 产生数据修改的undo数据 修改db buffer db writer将修改写入数据文件返回结果当语句执行完之后，服务端的一个进程专门负责将数据返回给客户端，从而完成整个查询过程。参考：https://www.cnblogs.com/zzl-156783663/p/8506488.html]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel生命周期]]></title>
    <url>%2F2019%2F09%2F14%2Flaravel%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[php生命周期 运行模式 CLI模式在终端输入php命令时使用的就是CLI模式 WEB模式当使用nginx或者其他web服务器作为宿主机处理请求时，使用的就是WEB模式 生命周期 模块初始化：调用php.ini中指明的扩展的初始化函数进行初始化工作，如mysql扩展 请求初始化：初始化脚本中所需要的变量名和变量值内容的符号表，如$_SESSION变量 执行php脚本 请求处理完成：按顺序调用各个模块的request shutdown方法，对每个变量调用unset方法 关闭模块：php调用每个模块的module shutdown方法，这是各个模块最后一次释放内存的机会 WEB模式和CLI模式的区别 CLI模式会在每次脚本执行经历5个完整的生命周期 WEB模式为了应对高并发，可能采用多线程，所以，可能1,5只执行一次，而2~4执行多次，以节省系统模块初始化带来的开销 总结理解这些，你就可以优化你的 Laravel 代码，可以更加深入的了解 Laravel 的singleton（单例）。至少你知道了，每一次请求结束，PHP 的变量都会 unset，Laravel 的 singleton 只是在某一次请求过程中的singleton；你在 Laravel 中的静态变量也不能在多个请求之间共享，因为每一次请求结束都会 unset。理解这些概念，是写高质量代码的第一步，也是最关键的一步。因此记住，PHP是一种脚本语言，所有的变量只会在这一次请求中生效，下次请求之时已被重置，而不像Java静态变量拥有全局作用。 laravel生命周期 生命周期 文件载入composer生成的自动加载设置，包括所有你 composer require的依赖。 1require __DIR__.'/../bootstrap/autoload.php'; 注册绑定服务，实例化Application，并绑定HttpKernel，ConsoleKernel ，ExceptionHandler 1$app = require_once __DIR__.'/../bootstrap/app.php'; 将请求分发到路由，处理请求，生成并发送响应（毫不夸张的说，你99%的代码都运行在这个小小的handle 方法里面）但是，请求是如何分发到路由的呢？具体而言就是，请求的分发是通过管道（Pipeline）实现的，而管道中有墙的阻碍。没错，墙就是中间件。请求需要首先经过全局中间件的审核，成功后才会分发到路由；分发到路由后，还要经过路由中间件的审核，然后请求才会被路由引导向控制器或闭包函数。 12345$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture());$response-&gt;send(); 请求结束，进行回调（还记得可终止中间件吗？没错，就是在这里回调的） 1$kernel-&gt;terminate($request, $response); 阅读本文后，建议阅读laravel框架启动过程 参考：https://www.cnblogs.com/fubuki/p/9695379.html]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel框架启动过程]]></title>
    <url>%2F2019%2F09%2F14%2Flaravel%E6%A1%86%E6%9E%B6%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[阅读本文前，建议先阅读laravel生命周期 核心文件了解laravel的读者都知道，public目录是laravel项目的入口，所以，laravel框架的整个启动流程就定义在public/index.php文件中。123456789101112131415161718define('LARAVEL_START', microtime(true));// 注册自动加载器require __DIR__.'/../vendor/autoload.php';// 实例化应用$app = require_once __DIR__.'/../bootstrap/app.php';// 处理请求和响应$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture());$response-&gt;send();$kernel-&gt;terminate($request, $response); 上面短短几行代码是如何将laravel框架运行起来的呢？请看下面具体分析 注册自动加载器启动一个框架，自然少不了在文件中加载大量的类，而laravel实现类的加载是十分轻松的！12345// 记录项目启动的时刻define('LARAVEL_START', microtime(true));// 注册类自动加载器require __DIR__.'/../vendor/autoload.php'; autoload.php是由composer提供的类自动加载器文件，包含它即可以实现自动加载框架类。 实例化应用包含了类文件后，接下来，就是实例化laravel应用。123456789101112131415161718192021222324252627$app = require_once __DIR__.'/../bootstrap/app.php';``` 通过上述一条语句实现了laravel application的实例化，下面分析下`$app`实例化的具体过程：``` php// bootstrap/app.php文件// 实例化$app$app = new Illuminate\Foundation\Application( realpath(__DIR__.'/../'));// 单例绑定共享的Kernel和异常处理器$app-&gt;singleton( Illuminate\Contracts\Http\Kernel::class, App\Http\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Console\Kernel::class, App\Console\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Debug\ExceptionHandler::class, App\Exceptions\Handler::class);return $app; 实例化$app 12345678910111213141516171819202122/** * Create a new Illuminate application instance. * * @param string|null $basePath * @return void */public function __construct($basePath = null)&#123; // 设置基础路径 if ($basePath) &#123; $this-&gt;setBasePath($basePath); &#125; // 注册基础绑定 $this-&gt;registerBaseBindings(); // 注册基础服务 $this-&gt;registerBaseServiceProviders(); // 注册核心容器别名 $this-&gt;registerCoreContainerAliases();&#125; 设置基础路径在容器中设置app、/、config、public、storage、database等目录的路径 1234567891011121314151617181920212223242526272829303132/** * Set the base path for the application. * * @param string $basePath * @return $this */public function setBasePath($basePath)&#123; $this-&gt;basePath = rtrim($basePath, '\/'); $this-&gt;bindPathsInContainer(); return $this;&#125;/** * Bind all of the application paths in the container. * * @return void */protected function bindPathsInContainer()&#123; $this-&gt;instance('path', $this-&gt;path()); $this-&gt;instance('path.base', $this-&gt;basePath()); $this-&gt;instance('path.lang', $this-&gt;langPath()); $this-&gt;instance('path.config', $this-&gt;configPath()); $this-&gt;instance('path.public', $this-&gt;publicPath()); $this-&gt;instance('path.storage', $this-&gt;storagePath()); $this-&gt;instance('path.database', $this-&gt;databasePath()); $this-&gt;instance('path.resources', $this-&gt;resourcePath()); $this-&gt;instance('path.bootstrap', $this-&gt;bootstrapPath());&#125; 绑定后的数组 $this-&gt;instances 如下: 123456789$this-&gt;instances['path'] = '/var/www/laravel/app'; $this-&gt;instances['path.base'] = '/var/www/laravel'; $this-&gt;instances['path.lang'] = '/var/www/laravel/resources/lang'; $this-&gt;instances['path.config'] = '/var/www/laravel/config'; $this-&gt;instances['path.public'] = '/var/www/laravel/public'; $this-&gt;instances['path.storage'] = '/var/www/laravel/storage'; $this-&gt;instances['path.database'] = '/var/www/laravel/database'; $this-&gt;instances['path.resources'] = '/var/www/laravel/resources'; $this-&gt;instances['path.bootstrap'] = '/var/www/laravel/bootstrap'; 注册基础绑定 123456789101112131415161718/** * Register the basic bindings into the container. * * @return void */protected function registerBaseBindings()&#123; static::setInstance($this); $this-&gt;instance('app', $this); $this-&gt;instance(Container::class, $this); // 包清单实例 $this-&gt;instance(PackageManifest::class, new PackageManifest( new Filesystem, $this-&gt;basePath(), $this-&gt;getCachedPackagesPath() ));&#125; 追加$this-&gt;instances 如下: 123$this-&gt;instances[&apos;app&apos;] = object(Illuminate\Foundation\Application); $this-&gt;instances[&apos;Illuminate\Container\Container&apos;] = object(Illuminate\Foundation\Application);$this-&gt;instances[&apos;PackageManifest&apos;] = object(PackageManifest); 注册基础服务注册事件、日志、路由服务 12345678910111213/** * Register all of the base service providers. * * @return void */protected function registerBaseServiceProviders()&#123; $this-&gt;register(new EventServiceProvider($this)); $this-&gt;register(new LogServiceProvider($this)); $this-&gt;register(new RoutingServiceProvider($this));&#125; 生成数组如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 event:$this-&gt;bindings['events'] = [ 'concrete' =&gt; function ($app) &#123; return (new Dispatcher($app))-&gt;setQueueResolver(function () use ($app) &#123; return $app-&gt;make(QueueFactoryContract::class); &#125;); &#125; 'shared' =&gt; 'true',];log:$this-&gt;bindings['log'] = [ 'concrete' =&gt; function () &#123; return function createLogger() &#123; $log = new Writer( new Monolog($this-&gt;channel()), $this-&gt;app['events'] ); if ($this-&gt;app-&gt;hasMonologConfigurator()) &#123; call_user_func($this-&gt;app-&gt;getMonologConfigurator(), $log-&gt;getMonolog()); &#125; else &#123; $this-&gt;&#123;$this-&gt;&#123;'configure'.ucfirst($this-&gt;handler()).'Handler'&#125;($log)&#125;($log); &#125; return $log; &#125; &#125; 'shared' =&gt; 'true',];router:$this-&gt;bindings['router'] = [ 'concrete' =&gt; function ($app) &#123; return new Router($app['events'], $app); &#125;, 'shared' =&gt; 'true',];$this-&gt;bindings['url'] = [ 'concrete' =&gt; function ($app) &#123; $routes = $app['router']-&gt;getRoutes(); $app-&gt;instance('routes', $routes); $url = new UrlGenerator( $routes, $app-&gt;rebinding( 'request', $this-&gt;requestRebinder() ) ); $url-&gt;setSessionResolver(function () &#123; return $this-&gt;app['session']; &#125;); $app-&gt;rebinding('routes', function ($app, $routes) &#123; $app['url']-&gt;setRoutes($routes); &#125;); return $url; &#125;, 'shared' =&gt; 'true',];$this-&gt;bindings['redirect'] = [ 'concrete' =&gt; function ($app) &#123; $redirector = new Redirector($app['url']); if (isset($app['session.store'])) &#123; $redirector-&gt;setSession($app['session.store']); &#125; return $redirector; &#125;, 'shared' =&gt; 'true',];$this-&gt;bindings[ServerRequestInterface::class] = [ 'concrete' =&gt; function ($app) &#123; return (new DiactorosFactory)-&gt;createRequest($app-&gt;make('request')); &#125;, 'shared' =&gt; 'true',];$this-&gt;bindings[ResponseInterface::class] = [ 'concrete' =&gt; function ($app) &#123; return new PsrResponse(); &#125;, 'shared' =&gt; 'true',];$this-&gt;bindings[ResponseFactoryContract::class] = [ 'concrete' =&gt; function ($app) &#123; return new ResponseFactory($app[ViewFactoryContract::class], $app['redirect']); &#125;, 'shared' =&gt; 'true',]; 注册核心容器别名 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public function registerCoreContainerAliases()&#123; $aliases = [ 'app' =&gt; [\Illuminate\Foundation\Application::class, \Illuminate\Contracts\Container\Container::class, \Illuminate\Contracts\Foundation\Application::class], 'auth' =&gt; [\Illuminate\Auth\AuthManager::class, \Illuminate\Contracts\Auth\Factory::class], 'auth.driver' =&gt; [\Illuminate\Contracts\Auth\Guard::class], 'blade.compiler' =&gt; [\Illuminate\View\Compilers\BladeCompiler::class], 'cache' =&gt; [\Illuminate\Cache\CacheManager::class, \Illuminate\Contracts\Cache\Factory::class], 'cache.store' =&gt; [\Illuminate\Cache\Repository::class, \Illuminate\Contracts\Cache\Repository::class], 'config' =&gt; [\Illuminate\Config\Repository::class, \Illuminate\Contracts\Config\Repository::class], 'cookie' =&gt; [\Illuminate\Cookie\CookieJar::class, \Illuminate\Contracts\Cookie\Factory::class, \Illuminate\Contracts\Cookie\QueueingFactory::class], 'encrypter' =&gt; [\Illuminate\Encryption\Encrypter::class, \Illuminate\Contracts\Encryption\Encrypter::class], 'db' =&gt; [\Illuminate\Database\DatabaseManager::class], 'db.connection' =&gt; [\Illuminate\Database\Connection::class, \Illuminate\Database\ConnectionInterface::class], 'events' =&gt; [\Illuminate\Events\Dispatcher::class, \Illuminate\Contracts\Events\Dispatcher::class], 'files' =&gt; [\Illuminate\Filesystem\Filesystem::class], 'filesystem' =&gt; [\Illuminate\Filesystem\FilesystemManager::class, \Illuminate\Contracts\Filesystem\Factory::class], 'filesystem.disk' =&gt; [\Illuminate\Contracts\Filesystem\Filesystem::class], 'filesystem.cloud' =&gt; [\Illuminate\Contracts\Filesystem\Cloud::class], 'hash' =&gt; [\Illuminate\Contracts\Hashing\Hasher::class], 'translator' =&gt; [\Illuminate\Translation\Translator::class, \Illuminate\Contracts\Translation\Translator::class], 'log' =&gt; [\Illuminate\Log\Writer::class, \Illuminate\Contracts\Logging\Log::class, \Psr\Log\LoggerInterface::class], 'mailer' =&gt; [\Illuminate\Mail\Mailer::class, \Illuminate\Contracts\Mail\Mailer::class, \Illuminate\Contracts\Mail\MailQueue::class], 'auth.password' =&gt; [\Illuminate\Auth\Passwords\PasswordBrokerManager::class, \Illuminate\Contracts\Auth\PasswordBrokerFactory::class], 'auth.password.broker' =&gt; [\Illuminate\Auth\Passwords\PasswordBroker::class, \Illuminate\Contracts\Auth\PasswordBroker::class], 'queue' =&gt; [\Illuminate\Queue\QueueManager::class, \Illuminate\Contracts\Queue\Factory::class, \Illuminate\Contracts\Queue\Monitor::class], 'queue.connection' =&gt; [\Illuminate\Contracts\Queue\Queue::class], 'queue.failer' =&gt; [\Illuminate\Queue\Failed\FailedJobProviderInterface::class], 'redirect' =&gt; [\Illuminate\Routing\Redirector::class], 'redis' =&gt; [\Illuminate\Redis\RedisManager::class, \Illuminate\Contracts\Redis\Factory::class], 'request' =&gt; [\Illuminate\Http\Request::class, \Symfony\Component\HttpFoundation\Request::class], 'router' =&gt; [\Illuminate\Routing\Router::class, \Illuminate\Contracts\Routing\Registrar::class, \Illuminate\Contracts\Routing\BindingRegistrar::class], 'session' =&gt; [\Illuminate\Session\SessionManager::class], 'session.store' =&gt; [\Illuminate\Session\Store::class, \Illuminate\Contracts\Session\Session::class], 'url' =&gt; [\Illuminate\Routing\UrlGenerator::class, \Illuminate\Contracts\Routing\UrlGenerator::class], 'validator' =&gt; [\Illuminate\Validation\Factory::class, \Illuminate\Contracts\Validation\Factory::class], 'view' =&gt; [\Illuminate\View\Factory::class, \Illuminate\Contracts\View\Factory::class], ]; foreach ($aliases as $key =&gt; $aliases) &#123; foreach ($aliases as $alias) &#123; $this-&gt;alias($key, $alias); &#125; &#125;&#125;public function alias($abstract, $alias)&#123; $this-&gt;aliases[$alias] = $abstract; $this-&gt;abstractAliases[$abstract][] = $alias;&#125; 生成数组如下： 1234567$this-&gt;aliases['Illuminate\Foundation\Application'] = 'app';$this-&gt;aliases['Illuminate\Contracts\Container\Container'] = 'app';$this-&gt;aliases['Illuminate\Contracts\Foundation\Application'] = 'app';$this-&gt;abstractAliases['app'][] = 'Illuminate\Foundation\Application';$this-&gt;abstractAliases['app'][] = 'Illuminate\Contracts\Container\Container';$this-&gt;abstractAliases['app'][] = 'Illuminate\Contracts\Foundation\Application';…… 单例绑定共享的Kernel和异常处理器单例绑定Http、Console的Kernel和异常处理器 1234567891011121314$app-&gt;singleton( Illuminate\Contracts\Http\Kernel::class, App\Http\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Console\Kernel::class, App\Console\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Debug\ExceptionHandler::class, App\Exceptions\Handler::class); 总结：12345设置基础路径（$this-&gt;instances[&apos;path.*&apos;]） =&gt; 注册基础绑定($this-&gt;instances[&apos;app|Container&apos;]) =&gt; 注册基础服务($this-&gt;bindings[]) =&gt; 注册核心容器别名($this-&gt;aliases[],$this-&gt;abstractAliases[])至此，应用的实例化完成。 处理请求和响应12345678910111213// 通过前面在$app中注册的Illuminate\Contracts\Http\Kernel::class，现在获取Http实例$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);// Kernel处理器调用handle方法处理当前请求，得到response$response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture());// 发送响应信息到浏览器$response-&gt;send();// 请求结束，进行回调$kernel-&gt;terminate($request, $response); 终于，laravel的启动讲完了。能看到这里说明你是一个有决心看源码的读者！加油，前路依然不平坦…参考：https://segmentfault.com/a/1190000008848349]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>laravel源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯算法（1）]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[七牛云上传图片并返回url]]></title>
    <url>%2F2019%2F09%2F06%2F%E4%B8%83%E7%89%9B%E4%BA%91%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%B9%B6%E8%BF%94%E5%9B%9Eurl%2F</url>
    <content type="text"><![CDATA[准备（1）注册七牛，实名认证获得30天的免费域名（也可以配置自己的域名）（2）创建存储空间（笔者使用的是公有空间） 配置本地开发环境（1）下载SDK（2）导入SDK进laravel框架（笔者导入目录的是app，方便引入方法到控制器）（3）指定路由，编写上传图片方法12345678910111213141516171819202122232425262728293031/** * 用户上传文件到七牛，并返回图片Url * @param Request $request * @return false|string * @throws \Exception */ public function upload(Request $request) &#123; // 获取鉴权 $auth = new Auth($this-&gt;accessKey, $this-&gt;secretKey); $token = $auth-&gt;uploadToken($this-&gt;bucket, null, 3600); // 上传文件 $image = $request-&gt;file(&apos;user_image&apos;); if ($image-&gt;isValid()) &#123; $localPath = $image-&gt;getRealPath(); $key = &apos;imgUrl_&apos;.microtime(true).&apos;.jpg&apos;; $uploadManager = new UploadManager(); if (!$uploadManager-&gt;putFile($token, $key, $localPath)) &#123; return Response::jsonResponse(109, &apos;图片上传失败&apos;); &#125; // 定义图片url $retUrl = $this-&gt;domainName.$key; return Response::jsonResponse(0, &apos;图片上传成功&apos;, [ &apos;callbackUrl&apos; =&gt; $retUrl ]); &#125; &#125; 测试使用postman测试接口]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>七牛云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串全排序]]></title>
    <url>%2F2019%2F09%2F06%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[传送门 https://leetcode-cn.com/problems/letter-tile-possibilities/ 题目描述你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。 示例 输入：”AAB”输出：8解释：可能的序列为 “A”, “B”, “AA”, “AB”, “BA”, “AAB”, “ABA”, “BAA”。 输入：”AAABBC”输出：188 题解123456789101112131415161718192021222324252627class Solution &#123; public int numTilePossibilities(String tiles) &#123; int[] counter = new int[26]; for (int i=0; i&lt;tiles.length(); i++) &#123; counter[tiles.charAt(i) - &apos;A&apos;] ++; &#125; return backTrace(counter); &#125; public int backTrace(int[] counter) &#123; int ans = 0; for (int i=0; i&lt;counter.length; i++) &#123; if (counter[i] == 0) continue; ans ++; counter[i] -- ; ans += backTrace(counter); counter[i]++; // 回溯 &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>回溯算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子集]]></title>
    <url>%2F2019%2F09%2F06%2F%E5%AD%90%E9%9B%86%2F</url>
    <content type="text"><![CDATA[传送门 https://leetcode-cn.com/problems/subsets/ 子集 I题目描述给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例 输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 题解代码理解不难，直接贴代码了123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); res.add(new ArrayList&lt;&gt;()); // 遍历数组每个元素，将其加入集合之前的元素中 for (int i = 0; i &lt; nums.length; i++) &#123; // 遍历集合中的每个元素 int all = res.size(); for (int j = 0; j &lt; all; j++) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(res.get(j)); tmp.add(nums[i]); res.add(tmp); &#125; &#125; return res; &#125; 传送门 https://leetcode-cn.com/problems/subsets-ii/ 子集 II题目描述给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例 输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] 题解该题比子集I多出一个操作，那就是去重，实现代码与子集I类似。1234567891011121314151617181920212223242526272829303132class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; // 排序 Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); list.add(temp); int j = 0, right = 0; for (int i=0; i&lt;nums.length; i++) &#123; int len = list.size(); right = len; for (; j&lt;len; j++) &#123; temp = new ArrayList&lt;&gt;(list.get(j)); temp.add(nums[i]); list.add(temp); &#125; // 去重 if (i != nums.length-1 &amp;&amp; nums[i] == nums[i+1]) &#123; j = right; &#125;else &#123; j=0; &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数相加||]]></title>
    <url>%2F2019%2F08%2F27%2F%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目描述：给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例： 输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出: 7 -&gt; 8 -&gt; 0 -&gt; 7 题解思路：由数字存储顺序得，无法直接相加两个单链表的值。为了可以直接相加两链表，所以反转两个链表。（分别求出链表代表的数字，再相加会超出int的范围）然后，用链表的头插法（逆序创建，负负得正）创建一个新的链表，并返回头结点。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; // 反转单链表需要先存储链表结点 public ListNode reverse(ListNode n) &#123; ListNode[] node = new ListNode[100]; int i = 0; while (n != null) &#123; node[i++] = n; n = n.next; &#125; i--; int j = i; while (i != 0) &#123; node[i].next = node[i-1]; i--; &#125; node[0].next = null; return node[j]; &#125; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; l1 = reverse(l1); l2 = reverse(l2); ListNode head = null, tail = null; // 解决进位问题，结果大于等于10时，剩余值到下一个循环 int n = 0; while (l1 != null || l2 != null || n != 0) &#123; if (l1 != null) n += l1.val; if (l2 != null) n += l2.val; tail = new ListNode(n%10); n /= 10; tail.next = head; head = tail; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>单链表</tag>
        <tag>单链表反转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表创建]]></title>
    <url>%2F2019%2F08%2F27%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[PS：头插法实现较简单，但生成内容为原内容的逆序；尾插法则为正序生成12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class ListNode&#123; public int val; public ListNode next; ListNode (int val) &#123; this.val = val; &#125;&#125;public class ListTest &#123; /** * 头插法 * @param nums * @return */ public static ListNode headInsert(int[] nums) &#123; ListNode head = null; ListNode tail = null; int len = nums.length, i=0; while (i &lt; len) &#123; tail = new ListNode(nums[i++]); tail.next = head; head = tail; &#125; return head; &#125; /** * 尾插法 * @param nums * @return */ public static ListNode tailInsert(int[] nums) &#123; ListNode head = null; ListNode tail = null; int len = nums.length, i = 0; while (i &lt; len) &#123; if (head == null) &#123; head = tail = new ListNode(nums[i++]); &#125;else &#123; tail.next = new ListNode(nums[i++]); tail = tail.next; &#125; &#125; tail.next = null; return head; &#125; /** * 遍历 * @param node */ public static void Traverse(ListNode node) &#123; while (node != null) &#123; System.out.println(node.val); node = node.next; &#125; &#125; public static void main(String[] args) &#123; int arr[] = &#123;1,2,3,4,5&#125;; ListNode head = null; head = headInsert(arr); //head = tailInsert(arr); Traverse(head); &#125;&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大二叉树]]></title>
    <url>%2F2019%2F08%2F26%2F%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[传送门 https://leetcode-cn.com/problems/maximum-binary-tree/ 题目描述给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： 二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。 示例： 输入：[3,2,1,6,0,5] 输出：返回下面这棵树的根节点： 6 / \ 3 5 \ / 2 0 \ 1 题解思路：题意清晰易懂，且明显可以看出解决问题方法是一个流程的重复，所以想到递归。流程： 找数组特定范围内的最大值，和最大值对应的数组下标 将最大值添加的树结点 以数组最大值下标为分割点，在分割的两部分重复上面两步骤 123456789101112131415161718192021222324252627282930313233class Solution &#123; public TreeNode create(int begin, int end, int[] nums) &#123; TreeNode node = null; // 只存下标有利于节省内存 int index = begin; for (int i=begin; i&lt;=end; i++) &#123; if (nums[i] &gt; nums[index]) &#123; index = i; &#125; &#125; //System.out.println(begin + &quot; &quot;+ index+ &quot; &quot; + end + &quot; &quot; + nums[index]); node = new TreeNode(nums[index]); if (index != begin ) node.left = create( begin, index-1 , nums ); if (index != end ) node.right = create( index+1 , end, nums ); return node; &#125; public TreeNode constructMaximumBinaryTree(int[] nums) &#123; if ( nums.length == 0 ) return null; return create(0, nums.length-1, nums); &#125;&#125; 扩展传送门 https://leetcode-cn.com/problems/maximum-binary-tree/ 思路：从题目样例中可以看出，数组是由给出的A树经过中序遍历，再加上附加值得到。然后创建最大树的方法与上面题解法完全一致。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public void inTraverse(TreeNode node, List&lt;Integer&gt; list) &#123; if ( node != null ) &#123; if ( node.left != null ) &#123; inTraverse( node.left, list ); &#125; list.add( node.val ); if ( node.right != null ) &#123; inTraverse( node.right, list ); &#125; &#125; &#125; public TreeNode create( int begin, int end, List&lt;Integer&gt; list) &#123; TreeNode node = null; int index = begin; for ( int i=begin; i&lt;=end; i++ ) &#123; if (list.get(i) &gt; list.get(index)) index = i; &#125; node = new TreeNode(list.get(index)); if (index != begin) node.left = create( begin, index-1, list); if (index != end) node.right = create( index+1, end, list); return node; &#125; public TreeNode insertIntoMaxTree(TreeNode root, int val) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); inTraverse(root, list); list.add(val); return create(0, list.size()-1, list); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式匹配]]></title>
    <url>%2F2019%2F08%2F23%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[传送门 https://leetcode-cn.com/problems/regular-expression-matching/ 题目描述：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &#39;.&#39; 和 &#39;*&#39; 的正则表达式匹配。 &apos;.&apos; 匹配任意单个字符 &apos;*&apos; 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例： 输入:s = “aa”p = “a”输出: false解释: “a” 无法匹配 “aa” 整个字符串。 输入:s = “aa”p = “a“输出: true解释: 因为 ‘‘ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。 输入:s = “ab”p = “.“输出: true解释: “.“ 表示可匹配零个或多个（’*’）任意字符（’.’）。 输入:s = “aab”p = &quot;c*a*b&quot;输出: true解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。 输入:s = “mississippi”p = &quot;mis*is*p*.&quot;输出: false 题解：自顶向下动态规划推荐详细解析 https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; enum Result&#123; t,f &#125; Result memo[][] = null; public boolean isMatch(String s, String p) &#123; memo = new Result[s.length()+1][p.length()+1]; return dp(s, p, 0, 0); &#125; public boolean dp(String s, String p, int i, int j) &#123; if (memo[i][j] != null) return memo[i][j] == Result.t; boolean ans = false; if (j == p.length()) // 当s，p长度都为0或者相等时 &#123; ans = (i == s.length()); &#125;else // j &lt; p.length() &#123; boolean first_match = (i &lt; s.length() &amp;&amp; ( s.charAt(i) == p.charAt(j) || p.charAt(j) == &apos;.&apos; ) ); if ( p.length() &gt; j+1 &amp;&amp; p.charAt(j+1) == &apos;*&apos; ) &#123; ans = ( dp(s, p, i, j+2) || first_match &amp;&amp; dp(s, p, i+1, j) ); &#125;else &#123; ans = first_match &amp;&amp; dp(s, p, i+1, j+1); &#125; &#125; memo[i][j] = ans? Result.t : Result.f; return ans; &#125;&#125; 自底向上动态规划处理方法与自顶向下相似，不过需注意数组越界问题。此外，需注意&amp;&amp;优先级大于||，当&amp;&amp;的左边为false时，程序不会执行&amp;&amp;的右边，所以下面程序才不会出现越界。12345678910111213141516171819202122232425class Solution &#123; public boolean isMatch(String s, String p) &#123; int m = s.length(), n = p.length(); boolean[][] dp = new boolean[m+2][n+2]; dp[m][n] = true; for (int i=m; i&gt;=0; i--) &#123; for (int j=n-1; j&gt;=0; j--) &#123; boolean first_match = i &lt; m &amp;&amp; s.charAt(i) == p.charAt(j) || p.charAt(j) == &apos;.&apos;; if (j &lt; n-1 &amp;&amp; p.charAt(j+1) == &apos;*&apos;) &#123; dp[i][j] = dp[i][j+2] || first_match &amp;&amp; dp[i+1][j] ; &#125;else &#123; dp[i][j] = first_match &amp;&amp; dp[i+1][j+1]; &#125; &#125; &#125; return dp[0][0]; &#125;&#125; PS：题解来源于力扣官方题解]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>动态规划</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通配符匹配]]></title>
    <url>%2F2019%2F08%2F23%2F%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[传送门 https://leetcode-cn.com/problems/wildcard-matching/ 题目描述：给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 &#39;?&#39; 和 &#39;*&#39; 的通配符匹配。 ‘?’ 可以匹配任何单个字符。‘*’ 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 说明: s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。 示例： 输入:s = “aa”p = “a”输出: false解释: “a” 无法匹配 “aa” 整个字符串。 输入:s = “aa”p = &quot;*&quot;输出: true解释: &#39;*&#39; 可以匹配任意字符串。 输入:s = “cb”p = “?a”输出: false解释: ‘?’ 可以匹配 ‘c’, 但第二个 ‘a’ 无法匹配 ‘b’。 输入: s = “adceb” p = “ab”输出: true解释: 第一个 &#39;*&#39; 可以匹配空字符串, 第二个 &#39;*&#39; 可以匹配字符串 “dce”. 输入:s = “acdcb”p = “a*c?b”输入: false 思路：（动态规划四要素）（1）状态f[i][j]表示字符串s的前i个字符是否可以和字符串p的前j个字符匹配（2）转移方程 如果字符串s的第i个字符和字符串p第j个字符相等 或者 字符串p第j个字符为 ‘?’， 那么f[i][j]取决于f[i-1][j-1]的值 如果字符串p的第j个字符为 &#39;*&#39;， 1）如果 &#39;*&#39; 匹配空串，那么f[i][j]取决于f[i][j-1]的值 2）如果 &#39;*&#39; 匹配字符串s第i个字符，那么f[i][j]取决于f[i-1][j]（eg：s（abc） p（a*） f[3][2] = f[2][2]） （3）初始化f[0][0] = truef[0][i] = f[0][i-1] &amp;&amp; p.charAt(i-1) == &#39;*&#39;表示字符串s的前0个字符能否和字符串p的前i个字符匹配（4）结果f[s.length()][p.length()]12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean isMatch(String s, String p) &#123; int n1 = s.length(), n2 = p.length(); boolean f[][] = new boolean[n1+1][n2+1]; // 状态：f[i][j]表示字符串s的前i个字符是否可以和字符串p的前j个字符匹配 // 初始化 f[0][0] = true; for (int i=1; i&lt;=n2; i++) &#123; f[0][i] = f[0][i-1] &amp;&amp; p.charAt(i-1) == &apos;*&apos;; &#125; // 转移方程 for (int i=1; i&lt;=n1; i++) &#123; for (int j=1; j&lt;=n2; j++) &#123; if (s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == &apos;?&apos;) &#123; f[i][j] = f[i-1][j-1]; &#125; if (p.charAt(j-1) == &apos;*&apos;) &#123; // s的第i个字符与p的第j个字符匹配 || p的第j个字符匹配空串 f[i][j] = f[i-1][j] || f[i][j-1]; &#125; &#125; &#125; // 结果 return f[n1][n2]; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>动态规划</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加油站]]></title>
    <url>%2F2019%2F08%2F21%2F%E5%8A%A0%E6%B2%B9%E7%AB%99%2F</url>
    <content type="text"><![CDATA[传送门 https://leetcode-cn.com/problems/gas-station/ 题目描述：在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明:如果题目有解，该答案即为唯一答案。输入数组均为非空数组，且长度相同。输入数组中的元素均为非负数。 示例： 输入: gas = [1,2,3,4,5] cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 输入: gas = [2,3,4] cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 官方题解思路：理解到“gas数组总和与cost数组总和之差小于0，则无法环路一周；否则可以环路一周”是前提。接着，由于环路方向唯一，正确的起点唯一，那么计算到每个加油站的剩余油量，如果小于0，那么自然到不了该加油站。所以，遍历一遍数组，累加下剩余油量，当剩余油量小于0时，重置为0并进入下一循环。如果最后剩余油量不小于0，最后的一次重置点即正确的起点。12345678910111213141516171819class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int n = gas.length; int sum = 0, ans = 0, start = 0; for (int i=0; i&lt;n; i++) &#123; sum += (gas[i] - cost[i]); if (ans &lt; 0) &#123; ans = (gas[i] - cost[i]); start = i; &#125;else &#123; ans += (gas[i] - cost[i]); &#125; &#125; return sum &gt;= 0 ? start : -1; &#125;&#125; 个人解法解题前提想到了，但是找起点的方法效率不高。1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int len = gas.length; int[] arr = new int[len]; int ans = 0; for (int i=0; i&lt;len; i++) &#123; arr[i] = gas[i] - cost[i]; ans += arr[i]; &#125; if (ans &lt; 0) return -1; for (int i=0; i&lt;len; i++) &#123; if (arr[i] &lt; 0) continue; int sum = arr[i]; for (int j=i+1; ; j++) &#123; if ((j%len) == i &amp;&amp; sum &gt;=0) &#123; return i; &#125; sum += arr[j%len]; if (sum &lt; 0) &#123; break; &#125; &#125; &#125; return -1; &#125;&#125;]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>java</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跳跃游戏]]></title>
    <url>%2F2019%2F08%2F21%2F%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[传送门 https://leetcode-cn.com/problems/jump-game/submissions/ 题目描述：给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例： 输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 题解：暴力递归模拟解法（超时） 自顶向下：在下标为0位置下，有n1个可跳点；n1个的其中一个可跳点中，又有n2个可跳点…如此延伸下去，以下标0位置为树根，其他可跳点为树结点，就构成了一个倒立树状的自顶向下树。 1234567891011121314151617// 自顶向下的递归模拟public boolean canJumpEnd(int index, int[] nums)&#123; if (index == nums.length-1) return true; // 避免数组越界 int longest = Math.min(index+nums[index], nums.length-1); // 模拟所有可跳的路径 for (int i=index+1; i&lt;=longest; i++) &#123; if (canJumpEnd(i, nums)) return true; &#125; return false;&#125;public boolean canJump(int[] nums) &#123; return canJumpEnd(0, nums);&#125; 自顶向下的动态规划解法（超时）思路：使用记忆表记录位置好坏，优化递归次数（如果可以跳到最后的位置，即好位置；如果不能，就是坏位置）1234567891011121314151617181920212223242526272829303132333435class Solution &#123; enum Index &#123; good, bad, unknown &#125; Index[] memo = null; public boolean canJumpEnd(int pos, int[] nums) &#123; if (memo[pos] != Index.unknown) &#123; return memo[pos] == Index.good ? true : false; &#125; int longest = Math.min(pos+nums[pos], nums.length-1); for (int i=pos+1; i&lt;=longest; i++) &#123; if (canJumpEnd(i, nums)) &#123; memo[i] = Index.good; return true; &#125; &#125; memo[pos] = Index.bad; return false; &#125; public boolean canJump(int[] nums) &#123; memo = new Index[nums.length]; for (int i=0; i&lt;nums.length; i++) memo[i] = Index.unknown; memo[nums.length-1] = Index.good; return canJumpEnd(0, nums); &#125; &#125; 自底向上动态规划解法（不超时，但耗时长） 自底向上：与自顶向下恰好相反，它是从最底端的树结点向上搜索的方法 思路：由于已知数组最后一个位置为好位置，所以从数组最后一个位置向上搜索可到达最后一个位置的位置。1234567891011121314151617181920212223242526class Solution &#123; enum Index &#123; good &#125; public boolean canJump(int[] nums) &#123; int len = nums.length; Index[] memo = new Index[len]; memo[len-1] = Index.good; for (int i=len-2; i&gt;=0; i--) &#123; int longest = Math.min(i+nums[i], len-1); for (int j=i; j&lt;=longest; j++) &#123; if (memo[j] == Index.good) &#123; memo[i] = Index.good; break; &#125; &#125; &#125; return memo[0] == Index.good; &#125; &#125; 自底向上动态规划 + 贪心（完美的解法）思路：在自底向上动态规划解法的基础上，使用一个变量记录数组中可到达数组最右位置的最左端位置的下标，避免了二次循环的遍历，节省运行时间。12345678910public boolean canJump(int[] nums) &#123; // 记录最左端位置，避免二次循环 int lastPos = nums.length - 1; for (int i=nums.length-1; i&gt;=0; i--) &#123; if (i + nums[i] &gt;= lastPos) lastPos = i; &#125; return lastPos == 0; &#125; 最后，提供个人的粗糙解法思路：在可跳范围内寻找下一步可跳的最大值（贪心），如果最大值对应位置为0，那么回溯前面的值（回溯）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; public boolean canJump(int[] nums) &#123; int len = nums.length; if (len == 1) return true; int i=0; while (true) &#123; // 数组越界 if (i + nums[i] &gt;= len-1) return true; int max = 0; // 查找最大值 for (int j=i; j&lt;=(i+nums[i]); j++) &#123; if (max &lt; nums[j]) max = nums[j]; &#125; System.out.println(max); // 逆序定位 for (int j=(i+nums[i]); j&gt;=i; j--) &#123; if (max == nums[j]) &#123; i = j; break; &#125; &#125; if (i + nums[i] &gt;= len-1) return true; else if (i + nums[i] &lt; len -1 &amp;&amp; nums[i + nums[i]]==0) // 回溯 &#123; for (int j=(i+nums[i]); j&gt;=i; j--) &#123; if (j + nums[j] &gt;= len-1) &#123; System.out.println(j + nums[j]); return true; &#125; &#125; return false; &#125;else if (i + nums[i] &lt; len -1 &amp;&amp; nums[i]==0) // 示例2情况 &#123; return false; &#125; // 跳一步 i = i + nums[i]; &#125; &#125;&#125; PS：除个人解法外，其余解法来源于力扣官方题解。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>动态规划</tag>
        <tag>java</tag>
        <tag>贪心算法</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将数组拆分成斐波那契序列]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[传送门 https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/ 题目描述：给定一个数字字符串 S，比如 S = “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。 形式上，斐波那契式序列是一个非负整数列表 F，且满足： 0 &lt;= F[i] &lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；F.length &gt;= 3；对于所有的0 &lt;= i &lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。 另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。 返回从 S 拆分出来的所有斐波那契式的序列块，如果不能拆分则返回 []。 示例： 输入：”123456579”输出：[123,456,579] 输入: “11235813”输出: [1,1,2,3,5,8,13] 输入: “112358130”输出: []解释: 这项任务无法完成。 输入：”0123”输出：[]解释：每个块的数字不能以零开头，因此 “01”，”2”，”3” 不是有效答案。 输入: “1101111”输出: [110, 1, 111]解释: 输出 [11,0,11,11] 也同样被接受。 思路：（1）如何取出子串使用substring（）函数（2）如何完全枚举使用回溯算法，枚举所有情况（3）如何判断符合斐波那契序列将字符串转化为整形，判断是否等于前两个元素之和1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public List&lt;Integer&gt; splitIntoFibonacci(String S) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); backTracking(S, 0, list); return list; &#125; // 回溯算法 private boolean backTracking(String s, int start, List&lt;Integer&gt; list) &#123; // 结束条件 if (start == s.length() &amp;&amp; list.size() &gt; 2) return true; for (int i = start; i&lt;s.length(); i++) &#123; String tmp = s.substring(start, i+1); // 排除情况（1、超出整形范围 2、以0开头的子串） if (Long.parseLong(tmp) &gt; Integer.MAX_VALUE) break; if (!&quot;0&quot;.equals(tmp) &amp;&amp; tmp.startsWith(&quot;0&quot;)) break; if (isFibonacci(tmp, list)) &#123; list.add(Integer.valueOf(tmp)); // 查找下一个 if (backTracking(s, i+1, list)) return true; // 回溯 list.remove(list.size()-1); &#125; &#125; return false; &#125; // 判断是否符合斐波那契序列 private boolean isFibonacci(String s, List&lt;Integer&gt; list) &#123; int len = list.size(); if (len &lt; 2) return true; if (list.get(len-1) + list.get(len-2) == Integer.valueOf(s)) return true; return false; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>algorithm</tag>
        <tag>java</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大利润（贪心算法）]]></title>
    <url>%2F2019%2F08%2F19%2F%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6%EF%BC%88%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[传送门 https://leetcode-cn.com/problems/ipo/ 题目描述假设 力扣（LeetCode）即将开始其 IPO。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。 给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。 总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。 示例 输入: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].输出: 4解释:由于你的初始资本为 0，你尽可以从 0 号项目开始。在完成后，你将获得 1 的利润，你的总资本将变为 1。此时你可以选择开始 1 号或 2 号项目。由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。 思路将启动资金和利润关联，然后按照利润降序排序。那么，只要判断当前资金是否足够启动资金并做出相应处理即可。有些时间没有敲这样的算法题，脑子生锈了，在此记录下… 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; class node implements Comparable&lt;node&gt; &#123; public int p; public int c; node (int p, int c) &#123; this.p = p; this.c = c;&#125; public int compareTo(node n) &#123; return n.p - this.p; // 降序 &#125; &#125; public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) &#123; List&lt;node&gt; list = new ArrayList&lt;node&gt;(); for (int i=0; i&lt;Capital.length; i++) &#123; list.add(new node(Profits[i], Capital[i])); &#125; Collections.sort(list); while (k != 0 &amp;&amp; !list.isEmpty()) &#123; int f = 0; for (node n : list) &#123; if (W &gt;= n.c) &#123; f=1; W += n.p; list.remove(n); k--; break; &#125; &#125; if (f==0) return W; &#125; return W; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>java</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的三种遍历]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[实现的代码都不繁琐，相信聪明如你，一定可以理解。所以就不啰嗦了，直接上代码吧。PS：思路来源–&gt;https://www.cnblogs.com/qjmnong/p/9135386.html 前序遍历–&gt;传送门（1）递归法123456789101112131415class Solution &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; if (root != null) &#123; list.add(root.val); if (root.left != null) &#123; preorderTraversal(root.left); &#125; if (root.right != null) &#123; preorderTraversal(root.right); &#125; &#125; return list; &#125;&#125; （2）迭代法（借助栈）12345678910111213141516171819202122232425class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // 借助栈数据结构用于树结点的回溯 Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); if (root != null) &#123; stack.push(root); while (!stack.isEmpty()) &#123; root = stack.pop(); list.add(root.val); if (root.right != null) &#123; stack.push(root.right); &#125; if (root.left != null) &#123; stack.push(root.left); &#125; &#125; &#125; return list; &#125;&#125; 中序遍历–&gt;传送门（1）递归法123456789101112131415161718class Solution &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if (root != null) &#123; if (root.left != null) &#123; inorderTraversal(root.left); &#125; list.add(root.val); if (root.right != null) &#123; inorderTraversal(root.right); &#125; &#125; return list; &#125;&#125; （2）迭代法1234567891011121314151617181920212223242526272829303132class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); if (root != null) &#123; stack.push(root); while (!stack.isEmpty()) &#123; // 保证遍历顺序：左-根-右 while (root.left != null) &#123; stack.push(root.left); root = root.left; &#125; // 处理右结点 while (!stack.isEmpty()) &#123; root = stack.pop(); list.add(root.val); if (root.right != null) &#123; stack.push(root.right); root = root.right; break; &#125; &#125; &#125; &#125; return list; &#125;&#125; 后序遍历–&gt;传送门（1）递归法123456789101112131415161718class Solution &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; if (root != null) &#123; if (root.left != null) &#123; postorderTraversal(root.left); &#125; if (root.right != null) &#123; postorderTraversal(root.right); &#125; list.add(root.val); &#125; return list; &#125;&#125; （2）迭代法12345678910111213141516171819202122232425// 该方法十分巧妙。逆序左-右-根的遍历顺序，以根-右-左开始遍历；然后借助List的末尾添加方法，负负得正，变为左-右-根的遍历顺序。class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); if (root != null) &#123; stack.push(root); while (!stack.isEmpty()) &#123; root = stack.pop(); if (root.left != null) &#123; stack.push(root.left); &#125; if (root.right != null) &#123; stack.push(root.right); &#125; list.add(0, root.val); &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反转链表]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[传送门 题目描述：反转一个单链表。 示例:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 题解：遍历法需要遍历、头、尾三个指针，从尾部开始反转12345678910111213141516171819/** * @param ListNode $head * @return ListNode */function reverseList($head) &#123; if ($head == null) return null; $prev = $p = $head; $tail = $head-&gt;next; while ($tail) &#123; $p = $tail; $tail = $p-&gt;next; $p-&gt;next = $prev; $prev = $p; &#125; $head-&gt;next = null; return $p;&#125; 数组法先遍历存储指针，再从头部开始反转123456789101112131415161718192021222324/** * @param ListNode $head * @return ListNode */function reverseList($head) &#123; if ($head == null) return null; $_head = null; $p = $head; $arr = []; while ($p-&gt;next) &#123; $arr[] = $p; $p = $p-&gt;next; &#125; $_head = $p; $i = count($arr); while($i != 0) &#123; $p-&gt;next = $arr[--$i]; $p = $arr[$i]; &#125; $arr[0]-&gt;next = null; return $_head;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>链表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[报名系统-完整版]]></title>
    <url>%2F2019%2F06%2F16%2F%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9F-%E5%AE%8C%E6%95%B4%E7%89%88%2F</url>
    <content type="text"><![CDATA[项目地址 项目展示报名页面 管理员登录 管理员页面（1）首页（2）新增（3）编辑（4）删除 自我评价优点：使用了laravel自带脚手架实现管理员登录，使得实现过程简单，并且功能完整，界面简洁。一些细节也照顾到了，比如报名表单的验证，异常的输出。不足：管理员首页的报名信息未按指定字段排列，并且没有实现分页和查询报名信息功能，一定上不方便用户浏览。]]></content>
      <categories>
        <category>web开发</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>后端</tag>
        <tag>报名系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[报名系统]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[编写前端代码(简易版，前端不做对输入正误的检测)在views目录下创建form.blade.php文件12345678910111213141516171819202122232425262728293031323334353637383940&lt;!Doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;报名页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 align=&quot;center&quot;&gt;报名页面&lt;/h3&gt; &lt;form action=&#123;&#123; url(&apos;sign/form&apos;) &#125;&#125; method=&quot;post&quot; &gt; &lt;div class=&quot;form-group&quot; align=&quot;center&quot;&gt; &lt;label&gt;学号&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;stuId&quot; class=&quot;form-control&quot; placeholder=&quot;学号&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; align=&quot;center&quot;&gt; &lt;label&gt;姓名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; class=&quot;form-control&quot; placeholder=&quot;名字&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; align=&quot;center&quot;&gt; &lt;label&gt;年龄&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot; class=&quot;form-control&quot; placeholder=&quot;年龄&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; align=&quot;center&quot;&gt; &lt;label&gt;邮箱&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;邮箱&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; align=&quot;center&quot;&gt; &lt;label&gt;学院&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;college&quot; class=&quot;form-control&quot; placeholder=&quot;学院&quot; &gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; align=&quot;center&quot;&gt; &lt;label&gt;专业&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;major&quot; class=&quot;form-control&quot; placeholder=&quot;专业&quot; &gt; &lt;/div&gt; &lt;div align=&quot;center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot; &gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 编写控制器、路由，并测试index页面是否打通123456789signControllerpublic function index()&#123; return view(&apos;form.sign&apos;);&#125;routeRoute::get(&apos;sign/index&apos;, &apos;signController@index&apos;);Route::post(&apos;sign/form&apos;, &apos;signController@form&apos;); PS：测试前需要关闭App/Http/MiddleWare/VerifyCsrfToken.php的csrf验证 创建模型、迁移文件在控制台下输入php artisan make:model Signphp artisan make:migration create_signs_tablePS：Model类默认的数据表为派生的Model类名+s,所以创建的数据表名为signs 编写迁移文件，修改.env文件，通过迁移文件在数据库中快速创建数据表123456789101112131415161718192021迁移文件Schema::create(&apos;signs&apos;, function (Blueprint $table) &#123; $table-&gt;bigIncrements(&apos;id&apos;); $table-&gt;integer(&apos;stuId&apos;); $table-&gt;string(&apos;name&apos;); $table-&gt;integer(&apos;age&apos;); $table-&gt;string(&apos;email&apos;); $table-&gt;string(&apos;college&apos;); $table-&gt;string(&apos;major&apos;); $table-&gt;timestamps(); &#125;);.env文件DB_DATABASE= databaseDB_USERNAME= usernameDB_PASSWORD= password 创建数据表artisan migratePS:如果提示字符过长，则在App/Providers/AppserviceProvider.php的boot方法定义字符长度Schema::defaultStringLength(225); 编写Api12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182报名APi：处理对输入的正确性检测以及向数据库写入class ApiSign&#123; /** * 判断输入是否正确 * @param $request * @return bool */ public function Judge($request) &#123; $arr = [ &apos;stuId&apos;, &apos;name&apos;, &apos;age&apos;, &apos;email&apos;, &apos;college&apos;, &apos;major&apos; ]; foreach ($arr as $key) &#123; if($request[$key] == null) &#123; throw new ApiException(ApiErrorCode::ERROR_INFO_NOT_COMPLETE); &#125; &#125; $stuId = $request[&apos;stuId&apos;]; if($stuId &lt; 20180000 || $stuId &gt;= 20190000 || !is_numeric($stuId)) &#123; throw new ApiException(ApiErrorCode::ERROR_STUID); &#125; $age = $request[&apos;age&apos;]; if(!is_numeric($age) || $age &lt; 18 || $age &gt; 100) &#123; throw new ApiException(ApiErrorCode::ERROR_AGE_NOT_EXIST); &#125; // 邮箱地址验证 if( !preg_match(&apos;/[a-zA-Z0-9]+@[a-zA-Z0-9]+.(com|cn)/&apos;, $request[&apos;email&apos;])) &#123; throw new ApiException(ApiErrorCode::ERROR_EMAIL); &#125; return true; &#125; /** * 向数据库中写入数据 * @param $request */ public function write($request) &#123; $stuId = intval($request[&apos;stuId&apos;]); $ret = DB::table(&apos;signs&apos;)-&gt;where(&apos;stuId&apos;, &apos;=&apos;, $stuId)-&gt;first(); $age = intval($request[&apos;age&apos;]); $time = time(&apos;Y-m-d H:i:s&apos;); if($ret == null) &#123; $sign = new Sign(); $sign-&gt;stuId = $stuId; $sign-&gt;name = $request[&apos;name&apos;]; $sign-&gt;age = $age; $sign-&gt;email = $request[&apos;email&apos;]; $sign-&gt;college = $request[&apos;college&apos;]; $sign-&gt;major = $request[&apos;major&apos;]; $sign-&gt;save(); throw new ApiException(ApiErrorCode::SUCCESS); &#125;else &#123; throw new ApiException(ApiErrorCode::ERROR_INFO_EXIST); &#125; &#125;&#125;异常Api：返回一些异常信息class ApiException extends \RuntimeException&#123; public function __construct(array $ApiErrorConst,Throwable $previous = null) &#123; $code = $ApiErrorConst[0]; $message = $ApiErrorConst[1]; parent::__construct($message, $code, $previous); &#125;&#125;class ApiErrorCode&#123; /** * 错误码定义 */ const SUCCESS = [0, &apos;success&apos;]; const ERROR_INFO_NOT_COMPLETE = [1, &apos;填写信息不全&apos;]; const ERROR_STUID = [2, &apos;学号不存在&apos;]; const ERROR_EMAIL = [3, &apos;邮箱错误&apos;]; const ERROR_INFO_EXIST = [4, &apos;报名信息已存在&apos;]; const ERROR_AGE_NOT_EXIST = [5, &apos;年龄不正确&apos;];&#125; ORM模型操作数据库的相关配置12345678910111213class Sign extends Model&#123; /** * 定义操作的数据表 * @var string */ protected $table = &apos;signs&apos;; /** * 设置时间戳格式 * @var string */ protected $dateFormat = &apos;Y-m-d H:i:s&apos;;&#125; Test！]]></content>
      <categories>
        <category>web开发</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>后端</tag>
        <tag>报名系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Z字形变换]]></title>
    <url>%2F2019%2F05%2F24%2FZ%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[传送门 https://leetcode-cn.com/problems/zigzag-conversion/ 题目描述：将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例： 输入: s = “LEETCODEISHIRING”, numRows = 3输出: “LCIRETOESIIGEDHN”解释：L C I RE T O E S I I GE D H N 输入: s = “LEETCODEISHIRING”, numRows = 4输出: “LDREOEIIECIHNTSG”解释:L D RE O E I IE C I H NT S G 个人思路：根据Z字形排列规律，先找出排在第1行的字符，按找出顺序加到返回的字符串中，再行数累加，重复操作。所以，关键就在于如何找出排在每行的字符。将倒立Z的左竖列和斜对角线上的字符(不包括下一个竖列的第一个字符)作为一个周期，竖行上的字符显然满足 (j+1)%t==i 条件，而对角线上的字符需要分类讨论，处理周期问题，常用的运算符为%。所以判断条件为 numRows-((j+1)%t-numRows)==i ， 整理得 (2*numRows-(j+1)%t)==i，又因为(j+1)%t==0的情况不是预期，所以要分类讨论下。此外，由于竖行和对角线的判断在最后一行时同时满足，故需要加个格外条件。最后，遗漏了当 numRows==1 时，程序会发生错误，需将该情况另外处理。1234567891011121314151617181920212223242526272829class Solution &#123;public: string convert(string s, int numRows) &#123; string str = &quot;&quot;; int len = s.size(); if(numRows==1) return s; int k=0,t = 2*numRows-2,ans=0; for(int i=1; i&lt;=numRows; i++) &#123; for(int j=0; j&lt;len; j++) &#123; if((j+1)%t==i &amp;&amp; i!=numRows) &#123; str+=s[j]; &#125; if((j+1)%t!=0 &amp;&amp; (2*numRows-(j+1)%t)==i) &#123; str+=s[j]; &#125;else if((j+1)%t==0 &amp;&amp; (2*numRows-t)==i) &#123; str+=s[j]; &#125; &#125; &#125; return str; &#125;&#125;;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[messageBoard]]></title>
    <url>%2F2019%2F05%2F03%2FmessageBoard%2F</url>
    <content type="text"><![CDATA[留言板功能实现（php入门小白）PS：HTML，CSS，以及留言板功能类型借鉴了大牛的博客资源，留言板具体功能为自己实现。 留言板功能（1）在主界面显示已添加的留言（2）添加留言（3）管理员登录（4）修改留言（5）删除留言 具体代码主界面： index.php &lt;html&gt; &lt;head&gt; &lt;title&gt;欢迎来到小灰灰的留言本吼吼吼&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; TD { font-size: 12px; line-height: 150%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=1 cellspacing=0 cellspadding=0 style=&quot;border-collapse:collapse&quot; align=center width=480 bordercolor=black height=382&gt; &lt;tr&gt; &lt;td height=100 bgcolor=#6c6c6c style=&quot;font-size:30px;line-height:30px&quot;&gt; &lt;font color=#ffffff face=&quot;黑体&quot;&gt;欢迎来到小灰灰的留言本吼吼吼&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=25&gt; &lt;a href=send.php&gt;[我要写留言]&lt;/a&gt; &lt;a href=login.php&gt;[管理留言]&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=200&gt; &lt;?php $conn = mysqli_connect(&apos;localhost&apos;, &apos;username&apos;, &apos;userpassword&apos;); if (!$conn) { die(&apos;connect error&apos; . mysqli_error($conn)); } $sql = &quot;SELECT * FROM messageboard ORDER BY dateline DESC&quot;; mysqli_select_db($conn, &apos;test&apos;); $retval = mysqli_query($conn, $sql); if (!$retval) { die(&apos;use database error!&apos;); } else { $dataNum = mysqli_num_rows($retval); $i = 0; while ($row = mysqli_fetch_assoc($retval)) { echo &apos;-&gt;[&apos; . $row[&apos;author&apos;] . &apos;] on &apos; . $row[&apos;dateline&apos;] . &apos; saied：&lt;br&gt;&apos; . $row[&apos;message&apos;]; if ($dataNum &gt; 1 &amp;&amp; (++$i) != $dataNum) echo &apos;&lt;hr&gt;&apos;; } } mysqli_close($conn); ?&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=80 bgcolor=#6c6c6c align=center&gt; &lt;font color=&quot;#FFFFFF&quot;&gt; 版权所有：&lt;a href=&quot;https://gitee.com/hui_net/LearnRecords&quot;&gt;小灰灰的码云&lt;/a&gt;&lt;br&gt; E-mail:neuq-xjh@foxmail.com &lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 留言界面： send.php &lt;!-- 1.用户填写留言部分 send.php --&gt; &lt;!-- 可以首先编写send页面，只有用户提交了留言才能进行后面的留言显示，留言管理等等 --&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;欢迎来到小灰灰的留言本吼吼吼&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- border-collapse:collapse合并表格的边框 --&gt; &lt;table border=1 cellspacing=0 cellspadding=0 style=&quot;border-collapse:collapse&quot; align=center width=600 bordercolor=black&gt; &lt;tr&gt; &lt;td height=100 bgcolor=#6c6c6c&gt; &lt;font style=&quot;font-size:30px&quot; color=#ffffff face=&quot;黑体&quot;&gt;欢迎来到小灰灰的留言本吼吼吼&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=30&gt; &lt;a href=send.php&gt;[我要写留言]&lt;/a&gt; &lt;a href=login.php&gt;[管理留言]&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=200&gt; &lt;form method=&quot;POST&quot; action=&quot;send.php&quot;&gt; &lt;table border=&quot;1&quot; width=&quot;95%&quot; id=&quot;table1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; bordercolor=&quot;#808080&quot; style=&quot;border-collapse:collapse&quot; height=&quot;265&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; height=&quot;30&quot;&gt; &lt;p align=&quot;center&quot;&gt;欢迎填写你的留言&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;40%&quot;&gt; &lt;p align=&quot;left&quot;&gt;你的名字&lt;/p&gt; &lt;/td&gt; &lt;td width=&quot;67%&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; size=&quot;25&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;40%&quot;&gt; &lt;p align=&quot;left&quot;&gt;留言内容&lt;/p&gt; &lt;/td&gt; &lt;td width=&quot;67%&quot;&gt; &lt;textarea rows=&quot;10&quot; name=&quot;content&quot; cols=&quot;58&quot;&gt;&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;99%&quot; colspan=&quot;4&quot;&gt; &lt;p align=&quot;center&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;B1&quot;&gt; &lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=80 bgcolor=#6c6c6c align=center&gt; &lt;font color=&quot;#FFFFFF&quot;&gt; 版权所有：&lt;a href=&quot;https://gitee.com/hui_net/LearnRecords&quot;&gt;小灰灰的码云&lt;/a&gt;&lt;br&gt; E-mail:neuq-xjh@foxmail.com &lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php $name = $_POST[&quot;name&quot;]; if ($name != null) { $content = $_POST[&quot;content&quot;]; $addtime = date(&quot;Y-m-d h:i:s&quot;); $link = mysqli_connect(&quot;localhost&quot;, &quot;username&quot;, &quot;userpassword&quot;); if ($link) echo &quot;connect success!&lt;br&gt;&quot;; else { echo &quot;connect error!&lt;br&gt;&quot;; } mysqli_select_db($link, &quot;test&quot;); $sql = &quot;INSERT INTO messageboard(author,dateline,message,response) VALUES(&apos;$name&apos;,&apos;$addtime&apos;,&apos;$content&apos;,&apos;&apos;)&quot;; mysqli_query($link, $sql); mysqli_close($link); echo &quot;&lt;script&gt; alert(&apos;留言成功!单击确定查看留言.&apos;); location.href=&apos;index.php&apos;; &lt;/script&gt;&quot;; } ?&gt; 登录界面： login.php &lt;!-- 3.管理员登录页面 login.php --&gt; &lt;!-- 供管理员登录 --&gt; &lt;!-- 体会session实现用户登录的方法 --&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;欢迎来到小灰灰的留言本吼吼吼&lt;/title&gt; &lt;/heda&gt; &lt;body&gt; &lt;table border=1 cellspacing=0 cellspadding=0 style=&quot;border-collapse:collapse&quot; align=center width=400 bordercolor=black height=&quot;358&quot;&gt; &lt;tr&gt; &lt;td height=100 bgcolor=#6c6c6c style=&quot;font-size:30px;line-height:30px&quot;&gt; &lt;font color=#ffffff face=&quot;黑体&quot;&gt;欢迎来到小灰灰的留言本吼吼吼&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=25&gt; &lt;a href=send.php&gt;[我要写留言]&lt;/a&gt; &lt;a href=login.php&gt;[管理留言]&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=178&gt; &lt;form method=&quot;POST&quot; action=&quot;login.php&quot;&gt; &lt;table border=&quot;1&quot; width=&quot;95%&quot; id=&quot;table1&quot; cellspcing=&quot;0&quot; cellpadding=&quot;0&quot; bordercolor=&quot;#808080&quot; style=&quot;border-collapse&quot; height=&quot;154&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; height=&quot;29&quot;&gt; &lt;p align=&quot;center&quot;&gt;欢迎管理员登录&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;32%&quot;&gt; &lt;p align=&quot;center&quot;&gt;用户名&lt;/P&gt; &lt;/td&gt; &lt;td width=&quot;67%&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; size=&quot;20&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;32%&quot;&gt; &lt;p align=&quot;center&quot;&gt;密 码&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; size=&quot;20&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;99%&quot; colspan=&quot;2&quot;&gt; &lt;p align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot; name=&quot;B1&quot;&gt;&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=80 bgcolor=#6c6c6c align=center&gt; &lt;font color=&quot;#FFFFFF&quot;&gt; 版权所有：&lt;a href=&quot;https://gitee.com/hui_net/LearnRecords&quot;&gt;小灰灰的码云&lt;/a&gt;&lt;br&gt; E-mail:neuq-xjh@Foxmail.com &lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php $guestName = $_POST[&apos;name&apos;]; $guestPass = $_POST[&apos;password&apos;]; if($guestName!=null &amp;&amp; $guestPass!=null){ $link = mysqli_connect(&apos;localhost&apos;,&apos;username&apos;,&apos;userpassword&apos;); if(!$link){ die(&apos;connect error&apos;.mysqli_error($link)); } mysqli_select_db($link,&apos;test&apos;); $sql = &quot;SELECT * FROM admin WHERE username=&apos;$guestName&apos;&quot;; $retval = mysqli_query($link,$sql); if(mysqli_num_rows($retval) &gt; 0){ $info = mysqli_fetch_array($retval); if($info[&apos;userpass&apos;]==$guestPass){ echo &quot;&lt;script&gt; alert(&apos;log success!&apos;); location.href=&apos;manage.php&apos;; &lt;/script&gt;&quot;; }else{ echo &quot;&lt;script&gt; alert(&apos;log fail!&apos;); &lt;/script&gt;&quot;; } }else{ echo &quot;&lt;script&gt; alert(&apos;guest not exist!&apos;); &lt;/script&gt;&quot;; } } ?&gt; 管理界面： manage.php &lt;!DOCTYPE HTML&gt; &lt;HTML&gt; &lt;Head&gt; &lt;meta http-equiv=&quot;CONTENT-TYPE&quot; ; content=&quot;text/html&quot; ; charset=&quot;UTF-8&quot;&gt; &lt;title&gt;留言列表&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; &lt;/style&gt; &lt;/Head&gt; &lt;body&gt; &lt;div&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Time&lt;/th&gt; &lt;th class=&quot;content&quot;&gt;Content&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;?php $conn = mysqli_connect(&apos;localhost&apos;, &apos;username&apos;, &apos;userpassword&apos;); if (!$conn) { die(&apos;connect error&apos; . mysqli_error($conn)); } mysqli_select_db($conn, &apos;test&apos;); $sql = &apos;SELECT * FROM messageboard&apos;; $retval = mysqli_query($conn, $sql); if ($retval) { while ($v = mysqli_fetch_assoc($retval)) { ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $v[&apos;id&apos;]; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $v[&apos;author&apos;]; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $v[&apos;dateline&apos;]; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $v[&apos;message&apos;]; ?&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;changeContent.php?id=&lt;?= $v[&apos;id&apos;] ?&gt;&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;delete.php?id=&lt;?= $v[&apos;id&apos;] ?&gt;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;?php } } else { echo &apos;mysqli_query() error!&apos;; } ?&gt; &lt;table&gt; &lt;/div&gt; &lt;/body&gt; &lt;a href=&quot;index.php&quot;&gt;&lt;------返回主界面------&gt;&lt;/a&gt; &lt;/HTML&gt; 修改界面： changeContent.php &lt;?php $id = $_GET[&apos;id&apos;]; $link = mysqli_connect(&apos;localhost&apos;, &apos;username&apos;, &apos;userpassword&apos;); mysqli_select_db($link,&apos;test&apos;); $sql = &quot;SELECT * FROM messageboard WHERE id=&quot; . $id; $retval = mysqli_query($link, $sql); if ($retval) { while ($row = mysqli_fetch_assoc($retval)) { ?&gt; &lt;form method=&quot;POST&quot; action=&quot;update.php&quot; &gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;&lt;?= $row[&apos;id&apos;] ?&gt;&quot;&gt; 你的名字：&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;name&quot; value=&quot;&lt;?= $row[&apos;author&apos;] ?&gt;&quot; /&gt;&lt;br /&gt; 留言内容：&lt;TEXTAREA NAME=&quot;content&quot; ROWS=&quot;8&quot; COLS=&quot;30&quot;&gt;&lt;?= $row[&apos;message&apos;] ?&gt;&lt;/TEXTAREA&gt;&lt;br /&gt; &lt;INPUT TYPE=&quot;submit&quot; value=&apos;提交修改&apos;/&gt; &lt;/FORM&gt; &lt;?php } } ?&gt; update.php &lt;?php $name = $_POST[&apos;name&apos;]; $content = $_POST[&apos;content&apos;]; $time = date(&quot;Y-m-d h:i:s&quot;); $link = mysqli_connect(&apos;localhost&apos;, &apos;username&apos;, &apos;userpassword&apos;); if (!$link) { die(&apos;connect error&apos; . mysqli_error($link)); } mysqli_select_db($link, &apos;test&apos;); $sql = &apos;UPDATE messageboard SET author=&quot;&apos; . $name . &apos;&quot;,message=&quot;&apos; . $content . &apos;&quot;,dateline=&quot;&apos; . $time . &apos;&quot; WHERE id=&quot;&apos; . $_POST[&apos;id&apos;] . &apos;&quot;&apos;; $retval = mysqli_query($link, $sql); if ($retval) { echo &apos;修改成功，3秒后自动跳转......&apos;; ?&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=manage.php&quot;&gt; &lt;?php } else { echo &apos;修改失败，3秒后自动跳转......&apos;; ?&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=manage.php&quot;&gt; &lt;?php } ?&gt; 删除界面： delete.php&lt;html&gt; &lt;?php $link = mysqli_connect(&apos;localhost&apos;, &apos;username&apos;, &apos;userpassword&apos;); if (!$link) { die(&apos;connect error&apos; . mysqli_error($link)); } mysqli_select_db($link, &apos;test&apos;); $id = $_GET[&apos;id&apos;]; $sql = &apos;DELETE FROM messageboard WHERE id=&apos;.$id; $retval = mysqli_query($link, $sql); if ($retval) { echo &apos;删除成功，3秒后自动跳转......&apos;; ?&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=manage.php&quot;&gt; &lt;?php } else { echo &apos;删除失败，3秒后自动跳转......&apos;; } ?&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>留言板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[loginBySession]]></title>
    <url>%2F2019%2F05%2F03%2FloginBySession%2F</url>
    <content type="text"><![CDATA[登录实现记录一次session实现有登录过期时间的登录功能 Login.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Login&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;hr size=&quot;1&quot;&gt; &lt;form action=&quot;log.php&quot; method=&quot;post&quot; &gt; 用户：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&apos;login&apos; value=&quot;登录&quot;&gt; &lt;/form&gt; Login.php &lt;?php header(&apos;content-type:text/html;charset=utf-8&apos;); //获取表单的用户名和密码 if ($_SERVER[&apos;REQUEST_METHOD&apos;] == &apos;POST&apos;) { if (empty($_POST[&apos;username&apos;])){ echo &quot;&lt;script&gt;alert(&apos;用户名不能为空！&apos;);location.href=&apos;login.html&apos;;&lt;/script&gt;&quot;; }else { $username=trim($_POST[&apos;username&apos;]); } if (empty($_POST[&apos;password&apos;])){ echo &quot;&lt;script&gt;alert(&apos;密码不能为空！&apos;);location.href=&apos;login.html&apos;;&lt;/script&gt;&quot;; }else{ $password=$_POST[&apos;password&apos;]; } } //连接数据库，查询并返回用户信息 $link = mysqli_connect(&apos;localhost&apos;,&apos;username&apos;,&apos;userpassword&apos;); if(!$link){ echo &apos;connect error!&apos;; } mysqli_select_db($link,&apos;test&apos;); $sql = &quot;SELECT userpass FROM admin WHERE username=&quot;.&quot;&apos;$username&apos;&quot;; $retval = mysqli_query($link,$sql); if($retval){ $retpass = $retval-&gt;fetch_row(); }else{ echo &apos;sql error!&apos;; } if($retpass){ if($password != $retpass[0]){ echo &quot;&lt;script&gt;alert(&apos;密码错误！&apos;);location.href=&apos;login.html&apos;;&lt;/script&gt;&quot;; }else{ $expire=3600; ini_set(&apos;session.gc_maxlifetime&apos;,$expire); //初始化PHP session的有效期为一小时 //更改php.ini配置文件的值，在脚本生命周期中有效，脚本结束则失效 if(empty($_COOKIE[&apos;PHPSESSION&apos;])){ session_set_cookie_params($expire); //该函数必须在session_start()函数前使用 session_start(); }else{ session_start(); setcookie(&apos;PHPSESSION&apos;,session_id(),time() + $expire); } if(isset($_SESSION[&apos;username&apos;])){ exit(&quot;您已经登入了，请不要重新登入！用户名：{$_SESSION[&apos;username&apos;]}---&lt;a href=&apos;logout.php&apos;&gt;注销&lt;/a&gt;&quot;); }else{ $_SESSION[&apos;username&apos;]=$username; } echo &quot;&lt;script&gt;alert(&apos;登录成功！&apos;);&lt;/script&gt;&lt;br&gt;&quot;; echo &quot;您好！{$_SESSION[&apos;username&apos;]},欢迎回来！&quot;; echo &quot;&lt;a href=&apos;logout.php&apos;&gt;注销&lt;/a&gt;&quot;; } }else{ echo &quot;&lt;script&gt;alert(&apos;没有此用户！&apos;);location.href=&apos;login.html&apos;;&lt;/script&gt;&quot;; } Logout.php &lt;?php header(&apos;content-type:text/html;charset=utf-8&apos;); session_start(); if(isset($_SESSION[&apos;username&apos;])){ session_unset($_SESSION[&apos;username&apos;]); //释放所有会话变量 session_destroy(); //销毁一个会话的全部数据 setcookie(session_name(),&apos;&apos;); //销毁保存在客户端 Cookie 中的 Session ID echo &quot;&lt;script&gt; alert(&apos;注销成功！&apos;); location.href=&apos;login.html&apos;; &lt;/script&gt;&quot;; }else{ echo &quot;&lt;script&gt; alert(&apos;注销失败！&apos;); &lt;/script&gt;&quot;; }]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>login</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[longestPalindrome]]></title>
    <url>%2F2019%2F05%2F03%2FlongestPalindrome%2F</url>
    <content type="text"><![CDATA[传送门 https://leetcode-cn.com/problems/longest-palindromic-substring/ 题目描述：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 输入: “cbbd”输出: “bb” 题解：个人超时算法(滑动窗口算法，易于理解）思路：从某一窗口长度开始，从0滑动到n-1的位置，判断子串是否为回文，再递增窗口长度。（窗口长度从1开始最一般，下面算法为从2开始） int check(string s) //判断是否为回文 { int n = s.size(); int k = n/2; if(k==0) { return 1; } else { int i=0,f=1; for(i; i&lt;k; i++) { if(s[i]!=s[n-i-1]) { f=0; break; } } if(f==1) { return 1; } else { return 0; } } } string longestPalindrome(string s) { int len = s.size(); if(len&lt;=1) { return s; } string str = &quot;&quot;; str+=s[0]; str+=s[1]; int f=0; for(int i=2; i&lt;len + 1; i++) { for(int j=0; j&lt;len-i+1 ; j++) { int k=0; string ss=&quot;&quot;; while(k&lt;i) //可用substr函数代替 { ss+=s[j+k]; k++; } if(check(ss)) { f=1; str = ss; break; } } } if(f==1) { return str; } str=&quot;&quot;; str+=s[0]; return str; } 动态规划算法思路：核心思想在于避免验证回文时的不必要的重复计算。从左往右验证，找出最长回文子串的开始与结束位置。递推公式为 P(i,j)=(s[i] == s[j]) &amp;&amp; (P[i-1][j+1])PS：需考虑字母数为偶数回文的特殊情况，和确定判断条件。 class Solution { public: string longestPalindrome(string s) { int len = s.size(); if(len &lt;= 1) return s; int left=0,right=0; int book[1000][1000]={0}; //1符合，0不符合 for(int i=0;i&lt;len;i++){ book[i][i]=1; //单个字母为回文 for(int j=i-1;j&gt;=0;j--){ book[i][j] = (s[i] == s[j]) &amp;&amp; (book[i-1][j+1] || i-j==1); //注意i-j==1条件不能少 //cout&lt;&lt;j&lt;&lt;&apos; &apos;&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;book[i][j]&lt;&lt;endl; if(book[i][j] &amp;&amp; (i-j)&gt;(right-left)){ left = j; right = i; } } } string longest=&quot;&quot;; longest=s.substr(left,right-left+1); return longest; } }; 中心扩展算法思路：由于回文关于中心对称，所以回文可以从中心展开，其中，共有2*n-1个中心（考虑字母数为偶数的回文）难点：expandAroundCenter()函数的返回值计算与start和end位置的确定。 class Solution { public: string longestPalindrome(string s) { int len = s.size(); if(len&lt;=1) return s; int start=0,end=0; for(int i=0;i&lt;len;i++){ int len1 = expandAroundCenter(s,i,i); int len2 = expandAroundCenter(s,i,i+1); //cout&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;len1&lt;&lt;&apos; &apos;&lt;&lt;len2&lt;&lt;endl; int len = len1 &gt; len2?len1:len2; if(len &gt; end-start){ if(len==len1){ //进一步归纳，len==len2情况的计算符合所有情况 start = i-len/2; end = i + len/2; }else{ start=i- (len-1)/2; end=i + len/2; } } } string longest=&quot;&quot;; longest=s.substr(start,end-start+1); return longest; } int expandAroundCenter(string s,int left,int right){ while(left&gt;=0 &amp;&amp; right&lt;s.size() &amp;&amp;s[left]==s[right]){ left--;right++; } return right-left-1; //注意长度不是right-left+1 } };]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>algorithm</tag>
        <tag>回文串</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lengthOfLongestSubstring]]></title>
    <url>%2F2019%2F05%2F02%2FlengthOfLongestSubstring%2F</url>
    <content type="text"><![CDATA[传送门 https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 题目简述：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 ： 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 题解：个人超时解法class Solution { public: int max=0; int notBelong(string s,char c){ int f=1; for(int i=0;i&lt;s.size();i++){ if(c==s[i]){ f=0; break; } } if(f==1) return 1; else return 0; } int lengthOfLongestSubstring(string s) { if(s.size()==0) //当s的长度为0或1时的出错情况任意忽视 return 0; else if(s.size()==1) return 1; else { for(int i=0;i&lt;s.size()-1;i++){ string str=&quot;&quot;; str+=s[i]; for(int j=i+1;j&lt;s.size();j++){ if(notBelong(str,s[j])){ str+=s[j]; }else{ if(str.size()&gt;max) max=str.size(); break; } } if(str.size()&gt;max) max=str.size(); } return max; } } }; 滑动窗口算法思路：窗口指由开始和结束索引i,j定义的一个集合。将子串存入一个容器，如果s[j]不包含于子串中，向右滑动索引j，即j++;如果s[j]包含于子串中，则i++，窗口缩小。其中，在j++之后，取ans和（j-i）的最大值，即在线得到子串长度的最大值。 class Solution { public: int lengthOfLongestSubstring(string s) { int n=s.size(); set&lt;char&gt; ss; int ans=0,i=0,j=0; while(i&lt;n &amp;&amp; j&lt;n){ if(find(ss.begin(),ss.end(),s[j])==ss.end()){ ss.insert(s[j++]); ans= ans&gt;(j-i)? ans: j-i; }else{ ss.erase(s[i++]); } } return ans; } }; map法优化：我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。如果s[j]在[i,j)范围内有与j&#39;重复的字符，不是逐渐增加i，而是直接跳过[i,j&#39;]的范围内的所有元素，将i变为j&#39;+1。（注意取i和j&#39;+1的较大值，eg：”abba”） class Solution { public: int lengthOfLongestSubstring(string s) { int n=s.size(); map&lt;char,int&gt; m; int ans =0; for(int j=0,i=0;j&lt;n;j++){ if(m.find(s[j])!=m.end()){ i= m[s[j]]&gt;i? m[s[j]]: i; } ans = ans &gt; (j-i+1)? ans : (j-i+1); m[s[j]]=j+1; } return ans; } };]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
</search>
